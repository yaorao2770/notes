******	 ERROR:

	1. npm rebuild node-sass

		module build failed: Error: no such file or directory, scandir 'E:/code/project/sif/client/sif-mgmet/node_module/node-sass/vendor'


npm cache clean --force  强制清除缓存

=========== nodejs 相关说明===========

如果当前nodejs版本过低，想升级版本：

	where node 		得到安装路径

	去官网下载最新的zip压缩包，替换到之前的安装路径下的nodejs目录，整个替换

自动刷新server文件, 而不用更改了每次都重启服务

	npm install -g nodemon

	或 npm install -g supervisor

	使用: nodemon test.js

	supervisor myapp

	总结: 为什么用node xxx之后，再次修改文件，必须重启才能看到最新结果

	因为node加载过一次文件后就将其缓存在内存中,以后再读取这个文件直接从内存中读取,所有以后再修改文件node都不会加载了,这样的设计提高了性能,但降低了开发效率

	nodejs 热部署工具


如何让node代码跑起来：

	mkdir test && cd test

	npm init

	在package.json中添加以下字段：

		"bin": {
		  "my-cli": "./index.js"  // my-cli 是name字段的值
		}

	此时建好的test目录下新建一个js文件,index.js,文件格式如下:

	#! node 			(这一行必须位于第一行，之前不能有空行)

	console.log('hello node!');

	执行node文件： node xxx.js


	全局安装你的包：

	npm install -g (在新建的目录下面执行该命令，即可全局安装)

	执行 name 字段的值，即可将代码跑起来

#. 什么时候使用 npm install --save（或者 --save-dev）    

    -save: 安装的模板记录到 package.json 的 dependencies 字段中。

    -save-dev: 安装的模板记录到 package.json 的 devDependencies 字段中。

    dependencies:   运行时的依赖，发布后，即生产环境下还需要用到的模块

    devDependencies:    开发时的依赖，里面的模块是开发时用的，发布时用不到它。比如测试类的模块都在这个节点中(mocha、chai、sinon、zombie、supertest等)

                        拿GAIA来说，

                        {
                            "less": "^2.7.0",
                            "node-sass": "4.9.2",       // 像sass,最后都是要转换成css的，生产环境中其实并没有sass的存在，所以放在devDependencies节点中（即npm install node-sass --save-dev）
                            "numeral": "^2.0.6",
                            "pre-commit": "^1.2.2",     // 提交代码时的格式检查工具, 生产环境也不需要
                            "protractor": "~5.1.0",
                            "scss-bundle": "^2.4.0",
                            "ts-node": "~3.2.0",
                            "tsickle": ">=0.25.5",
                            "tslib": "^1.7.1",
                            "tslint": "~5.7.0",
                            "typescript": "2.7.2"
                        } 


#. Eror-first callback

    错误优先的回调写法，需要注意2条规则:

        1. 回调函数的第一个参数一定是error对象,如果error发生了，他会作为第一个err参数返回，如果没有。一般做法是返回null

    Node中API的写法大部分是 Error-first callback,如下:

    fs.readFile('input.txt', (err, res) => {
        ....
    });

    (err, res) => { ... } 这种写法就是 Error-first callback,

1. path模块

	nodejs的path对象，用来处理目录

	http://blog.csdn.net/wbiokr/article/details/73612207
	
	path.dirname(agr); 返回文件目录 

	...

2. fs 模块

3. commander 包

	是npm依赖排名前十之一的模块，主要作用为命令行辅助，类似模块还有optimist

	npm install commander

	特点：  help自动生成

			强制选项

			选项参数解析

4. git上传node项目的时候，最后忽略node_modules目录，因为有时候该目录总是很大，

	touch .gitignore

	vim .gitignore:

			node_modules/

	git仓库没有该目录，但是安装node插件的时候最好加上 --save-dev ，这样即使git上传没有node_modules目录，重新clone该项目时，依然可以通过 npm install 重新下载依赖的包，重新生成该目录


#. 升级 nodejs 本身	

	需安装 npm install -g n

	n latest

	n stable

	n v8

#. 模块系统

	为了让nodejs文件可以相互调用，nodejs提供了一个简单的模块系统。

	模块是node应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个node文件就是一个模块，

	这个文件可能是js代码，json或者变异过的c/c++扩展。

	main.js

		var hello = require('./hello');		

		hello.world();

	hello.js

		exports.world = function() {
			console.log('hello world');
		}

	解析： 
		1. require('./hello')	表示引入当前目录下的hello.js文件

		2. reuqire 和 exports两个对象，其中exports是模块公开的接口，require用于从外部获取一个模块的接口，即所获取模块的exports对象

		3. hello.js 中world是exports对象的成员函数

#. exports 对象

	1. exports.world = function() {...}

		world是exports的成员函数

	2. module.exports = Animal; 

		 function Animal() {
			 var name;

			 this.setName = function (newName) {
				 name = newName;
			 };

			 this.sayHello = function() {
				 console.log(`Hello ${name}`);
			 }
		 }

		2. 这种方式等同于上面的写法
			module.exports = function(name) {
				this.name = name;
		 	}

		3. 不可以直接导出一个类的同时导出其他的变量或者方法

			services/user.server.js

				const x = 5; 

				module.exports = Person;

				module.exports.x = x;

				module.exports.getAllUsers = function() {
					return [1,2,3];
				};

			使用:

			const userService = require("./services/user.server");

			userService.x;	// undefined

			userService.getAllUsers();	// xxxx

			const person = new userService("join");



		这种方式是， 将一个对象封装到模块中，reqire的时候直接获取到这个对象。（即导出的是一个类，所以require后必须实例化才能用）

		模块接口的唯一变化是使用 module.exports = Animal 代替了 exports.wrold = function() {...}， 在外部引用该模块时，其接口对象就是要输出的Animal对象本身，而不是原先的exports

		` 第二种方式:

			test.js

				function Animal() {
					var name;

					this.setName = function (newName) {
						name = newName;
					};

					this.sayHello = function() {
						console.log(`Hello ${name}`);
					}
				}

				exports.Animal = Animal;

			output.js

				var module = require('test').Animal;	// 注意后面有 .Animal
				var animal = new module();
				animal.run(100);
				animal.getMeters();

		` 第三种方式：

			test.js

				var meter;

					exports.run = function(value) {
						meter = value;
					};

					exports.getMeters = function () {
						console.log(`Run ${meter}`);
					};

			output.js

				var module = require('test');
				module.run(100);
				module.getMeters();

#. 四类模块

	node中存在4类模块（原生模块和3种文件模块）

	优先级： 文件模块缓存 -> 原生模块 > 文件模块

		reuqire("http")

		尽管目录下存在 http/http.js  http.node  http.json, 但是这个语句都不会从这些文件中加载，而是从原生模块中加载

		尽管原生模块与文件模块的优先级不同，但是都会优先从文件模块的缓存中加载已经存在的模块

	缓存区： 原生模块也有一个缓存区，不管是什么类型的模块，都是优先从缓存区加载文件，如果缓存区没有被加载过，则调用原生模块的加载方式进行加载和执行

#. x.node

	LOAD_AS_FILE(X)

	如果X.node 是一个文件，将X.node作为二进制插件载入并停止执行


#. 原生模块

	http
	fs
	os			提供了基本的系统操作函数
	net			用于底层的网络通信,提供了服务端和客户端的操作
	dns			用于解析域名
	domain		简化异步代码的异常处理,可以捕捉处理try catch无法捕获的
	path 		提供了处理和转换文件路径的工具
	events		

#. require不会重复加载模块，无论调用多少次require，获得的模块都是同一个

	var hello1 = require('./hello');
	var hello2 = require('./hello');

	hello1.setName("join");
	hello2.setName("mike");

	hello1.getName();	// mike 因为hello1 和 hello2指向的是同一个实例

#. 包

	nodejs的包是一个目录，其中包含一个json格式的包说明文件 package.json，严格按照以下规则：

		package.json 必须在包的顶层目录下	

		二进制文件应该在 bin 目录下

		js代码应该在 lib 目录下

		文档应该在 doc 目录下

		单元测试应该在 test 目录下

	一个包中，如果package.json 或 package.json中的main字段不存在，会尝试寻找index.js或index.json或index.node作为包的接口

	somePackage/index.js

		exports.hello = function () {
			console.log('somePackage/index.js');
		};

	getPackage.js (与somePackage同级)

		var somePackage = require('./somePackage');		// 直接reuqire一个目录

		console.log(somePackage);	// {hello: [Function]}
		
		somePackage.hello();	// somePackage/index.js

	总结：

		1. 使用这种方法，可以把文件夹封装为一个模块，即所谓的包。

		2. 包通常是一些模块的集合，在模块的基础上提供了更高层的抽象，相当于提供了一些固定接口的函数库，通过定制 package.json, 我们可以创建更复杂，更完善，更符合规范的包用于关于发布		

		3. 关于 包 的模块接口文件

			· 如果该包下有 package.json 文件，并且该文件下有 main 字段，name包的模块接口文件就是该字段的value值指向的文件

			· 如果该包下有 package.json 文件，但是该文件中没有 main 字段，那么查看该包下是否有 index.js / index.node / index.json ，

	node如何解析模块:

		/root/src/moduleA.js:

			var x = require("./moduleB");

		调用require后,发生了什么？（应该从 require的是绝对路径还是相对路径分析，有不同的行为）

			1. 检查 /root/src/moduleB.js 文件是否存在,不存在进行下一步

			2. 检查 /root/src/moduleB 目录是否包含一个 package.json 文件, 并且json文件中指定了 main 属性,

			   如 "main": "lib/mainModule.js" , 那么node会引用 /root/src/moduleB/lib/mainModule.js, 不存在进行下一步

			3. 检查 /root/src/moduleB 目录是否包含 index.js index.node文件，这个文件会被隐式的当做那个文件夹下的 "main" 模块

		
		require的是绝对路径, var x = require("moduleB");

			非相对模块名的解析是个完全不同的过程。node会在 node_modules 里查找你的模块。node_modules可能与当前文件在同一级目录下，

			或者在上层目录中。node会向上级目录遍历，查找每个 node_modules 直到找到要加载的模块

			1. /root/src/node_modules/moduleB.js
			2. /root/src/node_modules/moduleB/package.json(如果指定了 "main" 字段)
			3. /root/src/node_modules/moduleB/index.js

			4. /root/node_modules/moduleB.js
			5. /root/node_modules/moduleB/package.json(如果指定了 "main" 字段)
			6. /root/node_modules/moduleB/index.js

			7. /node_modules/moduleB.js
			8. /node_modules/moduleB/package.json(如果指定了 "main" 字段)
			9. /node_modules/moduleB/index.js



#. __filename

	表示当前正在执行的脚本的文件名，它将输出文件所在位置的绝对路径

	如果在模块中，返回的值是模块文件的路径。

	console.log(__filename); 	// E:\code\mine\nodejs\test.js

#. __dirname

	表示当前执行脚本所在的目录

	console.log(__dirname); 	// E:\code\mine\nodejs

#. setTimeout(cb, ms);

	setTimeout(() => {
		console.log("setTimeout after 1s");
	}, 1000);

#. 同步方法，没有callback

	readFile(file, callback)  读取文件内容

	Error：

		var fs = require("fs);
		fs.readFileSync("form.txt", (err, data) => {
			if (err) return console.error(err);
			console.log('同步读取文件', data);
		});

		这是错误的，因为xxxSync 方法没有回调函数，这样是不会执行的

	Correct:

		var data = fs.readFileSync("form.txt");
		console.log('同步读取文件', data.toString());

		记得是 data.toString(), 如果不转化为string，读取出来的是Buffer文件

		<Buffer e8 8f 9c e9.....>

#. fs.open(filename, flags, [mode], callback)		

	flags:

		r：	只读模式打开
		r+：读写模式打开
		w:	以写入模式打开，如果文件不存在则创建

	callback:

		打开文件后回调函数， fd为一个整数，表示打开文件返回的文件描述符， window中又称文件句柄

	eg:

		var fs = require("fs");
		console.log("准备打开文件");
		fs.open("input.txt", "r+", (err, fd) => {
			if (err) return console.error(err);
			console.log("文件打开成功", fd);
		});

		flags: 'w' 表示，如果当前目录下没有input.txt文件，那么创建该文件

		fs.open(__dirname+'\input.txt', 'r+', callback)

		__dirname+'\input.txt'是绝对路径，等同于 'input.txt' 相对路径，

#. fs.stat(path, callback)		

	callback:

		err, stat, 其中stat是fs.stat对象的实例，即，fs.stat(path)执行后，会将stat类的实例返回给其回调函数。
		可以通过stats类中的提供方法判断文件的相关属性

	eg:

		fs.stat('input.txt', (err, stat) => {
			conosle.log(stat.isFile());			// true
			conosle.log(stat.isDirectory());	// false
		});

#. writeFile(file, data, callback)

	data:	将要写入的数据

	callback(err)	只包含错误信息

	eg:

		var fs = require("fs");

		var data = fs.readFileSync('input.txt');
		console.log('文件改写前的内容是', data);
		
		fs.writeFile('input.txt', '我是卖报的小行家', err => {
			if (err) return console.error('文件写入失败', err);

			fs.readFile('input.txt', (err, data) => {
				if (err) return console.error("读取文件失败", err);
				console.log("文件内容是", data.toString());
			});
		});

		如果 input.txt 文件存在，则写入的内容会覆盖旧的文件内容，

		文件不存在，则会新建该文件并写入内容

#. fs.read()

	通过文件描述符fd读取文件内容

	比readFile更底层一些

#. fs.write()	

	通过文件描述符fd写入文件内容

	比writeFile更底层一些

#. fs.fstat()

	获取文件状态信息, 同stats()相似, 但是, fstat需要fd文件描述符

	内核（Kernel）利用文件描述符（file descriptior）来访问文件，文件描述符是非负整数。

	打开现存文件或新建文件时, 内核会返回一个文件描述符, 读写文件也需要fd来指定带读写的文件

#. Buffer 缓冲区

	js语言本身只有字符串数据类型，没有二进制数据类型。

	但在处理像TCP流或文件流时，必须使用到二进制数据。

	因此在node中，定义了一个Buffer类，该类用来创建一个专门存放二进制数据的缓存区。

	在node中，Buffer类是随Node内核一起发布的核心库。Buffer库为Node带来了一种存储原始数据的方法，可以让node处理二进制数据，

	每当需要在node中处理I/O操作中移动的数据时，就有可能使用Buffer库。

	原始数据存储在Buffer类的实例中。一个Buffer类似于一个整数数组，但它对应于V8堆内存之外的一块原始内存。

	
#. rmdir 和 readdir

	删除目录: fs.rmdir(path, (err) => {...})

	读取目录: fs.readdir(path, (err, files) => {...})

			 files为目录下的文件数组列表

			 读取当前目录的path应该写  ./

	eg：

		console.log("准备删除 /tmp/test 目录"));

		fs.rmdir("../tmp/test", (err) => {
			if (err) return console.log("rmdir--error", err);

			console.log("准备读取 /tmp 目录"));

			fs.readdir("../tmp", (err, files) => {
				if (err) return console.log("readdir--error", err);

				files.forEach(file => console.log(file));
			});
		});

---------------

		console.log("准备创建目录 uniqule");
		fs.mkdir("../uniqule", (err) => {
			if (err) return console.log("mkdir--error", err);
			console.log("目录创建成功");

			fs.writeFile("../uniqule/index.js", "我是通过writeFile新建的文件, 内容是apple", (err) => {
				if (err) return console.log("writeFile---error", err);

				console.log("writeFile--success");
				console.log("准备读取 /uniqule 目录");

				fs.readdir("../uniqule", (err, files) => {
					if (err) return console.log("readdir--error", err);

					console.log("uniqule目录下的文件有", files);
				});

				fs.readFile("../uniqule/index.js", (err, data) => {
					if (err) return console.log("readFile---error", err);

					console.log("uniqule/index.js的内容是", data.toString());
				});
			});
		});

---------------

		console.log("准备读取 /tmp 目录下的文件");

		var test = function (path) {
			fs.readdir(path, (err, files) => {
				if (err) return console.log("readdir---error", err);
			
				console.log(`${path}目录下的文件有`, files);
			
				files.forEach(file => {
					fs.stat(`${path}/${file}`, (err, stats) => {
						if (stats.isDirectory()) {
							test(`${path}/${file}`);
						}
					});
				});
			});
		};

		test("../tmp");		

#. ftruncate(fd, length, (err))  截取文件内容

	fd: 通过fs.open()方法返回的文件描述符

	length:  文件内容截取的长度

	eg:

		var buf = new Buffer.alloc(1024);

		fs.open("input.txt", "r+", (err, fd) => {
			if (err) return console.log("open--error", err);

			console.log("文件打开成功");
			console.log("准备截取10字节的文件内容");

			fs.ftruncate(fd, 10, (err) => {
				if (err) return console.log("ftruncate--error", err);

				console.log("截取成功");
				console.log("读取文件");

				fs.readFile("input.txt", (err, data) => {
					if (err) return console.log("readFile--err", err);

					console.log("文件内容是", data.toString());
				});

				fs.close(fd, err => {
					if (err) return console.log("close---error", err);

					console.log("文件关闭成功");
				});
			});
		});

#. exists(path, exists)

	是否存在文件或目录

	eg：

		console.log("准备删除文件");

		fs.unlink("input.txt", err => {
			if (err)  return console.log("unlink--error", err);

			console.log("删除文件成功");

			fs.exists("input.txt", isExists => {
				console.log("是否还存在该文件", isExists);
			});
		});

#. 需要fd的文件系统接口有

	Buffer.alloc(size[, fill[, encoding]])   
	返回一个指定大小的Buffer实例，如果没有设置fill， 则默认填满0

	var buf = new Buffer.alloc(1024);	// 创建一个长度为1024,且用0填充的buffer实例

	fs.open(filename, mode, (err, fd) => {

		fs.read(fd, buf, 0, buf.length, 0, (err, bytes) => {})

		fs.write(fd, buf, offset, length, position, cb)

		fs.fstat(fd, (err, stats) => {})

		fs.close(fd, err => {})
	});

#. URL

	const url = require("url);

	const myUrl = new URL("https:www.baidu.com:443/foo/name=join&age=12#bar");

	console.log(myUrl.port);		// 空字符串(默认端口将自动转换为空字符串)

	console.log(myUrl.pathname);	// foo/name=join&age=12

	console.log(myUrl.origin);		// https:www.baidu.com:443  protocol + host

	console.log(myUrl.host);		// www.baidu.com:443 包含端口号

	console.log(myUrl.hostname);	// www.baidu.com 不包含端口号

	console.log(myUrl.href);		// https:www.baidu.com:443/foo/name=join&age=12#bar

		获取href属性的值就相当于调用 url.toString()

		myUrl.href = "ws:baidu.com:2323"; 重新设置href值就相当于调用 new URL(value)

#. GET / POST


	可以在url中手动输入url组成,

	const http = require("http");
	const url = require("url");
	const util = require("util");

	http.createServer((req, res) => {
		res.writeHead(200, {"Content-Type": "text/plain"});

		const params = url.parse(req.url, true);
		res.write(`port: ${params.port}`);
		res.write("\n");
		res.write(`host: ${params.host}`);
		res.write("\n");
		res.write(`href: ${params.href}`);
		res.write("\n");
		res.write(`query--name: ${params.query.name}`);
		res.write("\n");
		res.write(`query--url: ${params.query.url}`);
		res.end();
	}).listen(3000);

	2. 在页面上输出整个url对象

		如果response返回的数据是中文的话，要做编码设置，否则乱码

		res.writeHead(200, {'Content-Type': 'text/plain; charset=utf-8'});

		http.createServer(function(req, res){
			res.writeHead(200, {'Content-Type': 'text/plain; charset=utf-8'});
			res.end(util.inspect(url.parse(req.url, true)));
		}).listen(3000);


#. util模块

	cosnt util = require("util");

	1. isBooleanObject 只有 new Boolean() 实例才返回true

		util.types.isBooleanObject(true);
		util.types.isBooleanObject(false);
		util.types.isBooleanObject(1234);
		util.types.isBooleanObject(new Boolean(true));		// true
		util.types.isBooleanObject(new Boolean(false));		// true
		util.types.isBooleanObject(Boolean(false));

	2. isDate

		util.types.isDate(new Date());		// true
		util.types.isDate(Date.now());		

	3. isGeneratorFunction  和 isGeneratorObject

		util.types.isGeneratorFunction(function* test() {});	// true

		function* bar() {
			console.log(111);
		}

		const barFn = bar();

		util.types.isGeneratorObject(barFn);	// true

	4. isRegExp

		这个比较特殊, 大部分的isXXXObject() 都需要是new xxx()才会返回true,但是这个方法不需要,以下两种方式都会返回true

		util.types.isRegExp(/123/);
		util.types.isRegExp(new RegExp('abc'));

#. querystring模块

	总共有四个API

	querystring.parse()  反序列化
	querystring.stringify()  序列化
	querystring.escape()  编码
	querystring.unescape()  解码

	eg: 

		parse之前: ?name=join&url=baidu.com&url=123

        body = querystring.parse(body);

		parse之后: {"?name": join, url: ["baidu.com", "123"]}

			注意, 如果前面有?号,那么parse后的结果这个?号并不会去掉

		2. escape 

			encodeURIComponent("测试");

			qs.escape("测试");		// 这两个方法编码的效果是一样的

		3. unescape

			decodeURIComponent("%E6%B5%8B%E8%AF%95");

			qs.unescape("%E6%B5%8B%E8%AF%95");

#. 201 Created

	状态码

#. http模块

	http.createServer( (req, res) => {});

	注意： 注意参数位置,第一个是 request, response

	requst: 是http.IncomingMessage的一个实例, 一个http request对象是可读流

	response: 是http.ServerResponse的一个实例, http server对象是可写流

	res.writeHead(200, {
		"Content-Length": body.length
	});

	Content-Length是以字节（byte）计算,而不是以字符（character）计算

	格式:

		1. 
			const http = require("http");
			const server = http.createServer();
			server.on("request", (req, res) => {
				res.statusCode = 200;
				const method = req.method;		// 请求方法 POST  GET  DELETE ...
				res.end("I`m data");
			}).listen(8080);

		2. 
			const http = require("http");
			http.createServer((req, res) => {
				res.statusCode = 200;
				res.write("123");
				console.log("url:", req.url);	// 如果是通过localhost:8080访问的话,就输出/,如果是http://localhost:8080/shanghai?location=china,输出/shanghai?location=china
				res.end();
			}).listen(8080);

		3. createServer中的request参数

			request.method   获取请求方法

			request.headers  获取请求头

			request.url  	 获取请求URL（queryString可以解析url中的query查询参数部分）

			request.on("data", data => {...})  监听post的body数据传输

			request.on("end", data => {...})  post的body数据传输结束

		4. 	createServer中的response参数

			response.write(string);

			response.end(string);

			response.statusCode = 200;

			response.writeHead(200, {"Content-Type": "text/html; charset=utf-8"});

		5.

			const contentType = request.headers["content-type"];

			if (contentType !== "application/json") {
				res.statusCode = 400;
				result = "error";
				res.end("error");
			}	

	1. 
		res.write(data.toString());
		res.end();		// 传送http响应

		等同于

		res.end(data);

		不管是write还是end中传输数据,都必须是string类型的

		write和end都是直接像浏览器界面输出了数据？？？？？怎么在client调用node的接口

	2. POST

		post请求的数据会被写入缓冲区中,需要通过request的data事件和end事件来进行数据拼接处理

		消息体: 用户输入的body

		http.ServerRequest并没有一个属性内容为请求体,原因是等待请求体传输可能是一件耗时的工作,

		比如上传文件,而很多时候我们可能并不需要理会请求体的内容,恶意的POST请求会大大消耗服务器的资源,所以node

		默认是不会解析请求体的,当你需要的时候,需要手动来做。

		const http = require("http");
		const querystring = require("querystring");

		var postHTML = 
			'<html><head><meta charset="utf-8"><title>菜鸟教程 Node.js 实例</title></head>' +
			'<body>' +
			'<form method="post">' +
			'网站名： <input name="name"><br>' +
			'网站 URL： <input name="url"><br>' +
			'<input type="submit">' +
			'</form>' +
			'</body></html>';

		http.createServer((req, res) = {
			let body = [];
			let body = '';

			req.on("data", (chunk) => {
				body.push(chunk);		// 1. body 是数组
				body += chunk;			// 2. body 是字符串
			});

			req.on("end", () => {
				body = querystring.parse(Buffer.concat(body).toString());
				body = querystring.parse(body);

				res.writeHead(200, {"Content-Type": "text/html; charset=utf-8"});

				if (body.name && body.url) {
					res.write(`username: ${body.name}`);
					res.write("<br>");
					res.write(`URL: ${body.url}`);
				} else {
					res.write(postHTML);
				}

				res.end();
			});
		}).listen(3000);

	` body不是用户输入的，是读取文件, 从而输出到界面上

		http.createServer((req, res) => {
			let body = "";
			req.on("data", (chunk) => {
				body += chunk;
			});

			req.on("end", () => {
				body = querystring.parse(data);
				res.writeHead(201, {"Content-Type": "text/html; charset=utf-8"});

				fs.readFile("../fsinput.txt", (err, data) => {
					if (err) return console.log("readFile---error", err);
					console.log("读取文件成功");
					res.end(data);
				});
			});
			
		}).listen(3000);

		console.log("服务器已启动");

	3. response.write(value);

		传输的数据必须是流或者字符串

	4. API

		http.createServer((req, res) =>{
			const url = req.url;
			let result;
			if (reqUrl.search("personal-info") > -1) {
				result = "personal-info request API";
			} else if (reqUrl.search("material") > -1) {
				result = "material API";
			} else {
				result = "nothing!";
			}
			res.end(result);
		}).listen(8080);	

	5. http.Server对象和直接的 http.createServer是相等的

		http.createServer((req, res) => {...});

		相等于:

		var server = new http.Server();
		server.on("request", (req, res) => {...})

		总结:

			以上代码是通过直接创建一个http.Server对象,然后为其添加request事件监听,其实也就是说createServer方法其实本质上

			也就是为http.Server对象添加了一个request事件监听

#. http.IncomingMessage	

	是HTTP请求的信息,一般是由http.Server的request事件发送,并作为第一个参数传递,包含三个事件:

	1. data

		当请求体数据到来时,该事件被触发,该事件提供一个参数chunk,表示接受的数据

		如果该事件没有被监听,则请求体会被抛弃,该事件可能会被调用多次

	2. end

		当请求体数据传输完毕时,该事件会被触发,伺候不会再有数据

	3. close

		用户当前请求结束时,该事件被触发,不同于end,如果用户强制终止了传输,也是用close

#. path 模块

	1. isAbsolute 判断是否是绝对路径

		path.isAbsolute("E:\code\mine\nodejs\path.js");	// false linux和windows文件分隔符不同
		path.isAbsolute("E:/code/mine/nodejs/path.js");	// true
		path.isAbsolute("/path.js");					// true
		path.isAbsolute("/url/");						// true

	2. join	链接不同路径,主要是不同系统的文件分隔符不同,

		path.join(__dirname, "nodejs", "url", "get.js");	// nodejs\url\get.js  linux下是\,win下是/

	3. resolve 将路径转换为绝对路径

		path.resolve("path.js");	// E:/code/mine/nodejs/path.js

	4. relative(from, to)  转化为相对路径

		path.relative("path.js", "url/get.js");	// ../url/get.js

	5. dirname	获取路径中的目录名

		path.dirname("url/get.js");	// url

	6. basename 获取路径中的文件名,如果有第二个参数,说明输出的文件名中不包含后缀名

		path.basename("url/get.js");		 // get.js
		path.basename("url/get.js", ".js");	 // get

	7. extname 	获取文件的后缀名

		path.extname("url/get.js");	// .js

	8. sep 属性, 返回当前系统的文件分隔符

		path.sep	// win是/, linux是\

#. events 模块

	该模块只提供一个对象: events.EventEmitter

	EventEmitter的核心就是事件触发与事件监听器功能的封装

#. const { Service } = require("egg");

	等同于

	const server = require("egg).Server;

#. 常用端口

	ssh			22
	http		80
	https		443
	mongodb		27017

#. Content-Type: application/octet-stream

	以流的形式下载文件, 这样可以实现任意格式的文件下载

	如果想指定文件名的话，配合 Content-Disposition 使用

	Content-Type: application/octet-stream

	Content-Disposition: attachment;filename=test.pdf

#. Content-Disposition

	当用户想把请求所得的内容存为一个文件的时候提供一个默认的文件名

#. res.send(new Buffer("<p>p element</p>"));

	当发送的是Buffer类型的数据时， Response header default is Content-Type: application/octet-stream

	除非你自定义:

	res.set("Content-Type", text/html");
	res.send(new Buffer("<p>p element</p>"));

#. Stream 模块

	const readStream  = fs.createReadStream("./demo.txt");
	const writeStream = fs.createWriteStream("./input.txt");

	流是一个抽象接口，被node中的很多对象所实现。比如对一个HTTP服务器的请求是一个流，stdout也是一个流。

	流是可读，可写或兼具两者的。

	当内存中无法一次装下需要出来的数据时，或者一边读取一边处理更加高效时，我们就需要用到数据流。

	流的传输过程默认是以 buffer 的形式传输的，除非你给他设置其他编码形式。

	使用中的陷阱（node http处理大文件的方法）:

		normal：

			const rs  = fs.createReadStream("./demo.txt");
			rs.on("data", chunk => {
				res.write(chunk);
			});
			rs.on("end", chunk => {
				res.end();
			});

		优化:

			rs.pipe(res);  // 使用pipe可以解决读写不平衡问题

			因为pipe方法每次写数据的时候，都会判断是否谢成功。如果写失败，会等待可写流触发 drain 事件,

			表示可写流可以继续写数据了,然后pipe才回继续写数据.

			也就是说，normal的写法中我们没有判断 res.write(chunk) 是否执行成功,就继续写，这样如果文件比较大，

			而可写流的写速度比较慢的话，会导致大量的buff缓存在内存中,就会导致内存撑爆的情况。

		总结：
			
			在使用流的过程中,一定要注意可读流和可写流和写之间的平衡,否则会导致内存泄漏

			stream类的 pause() 和 resume() 两个方法, 这样的话我们也可以自己控制写的平衡

		为什么会内存泄漏:

			如果chunk被缓存以后，发现缓冲区超过预先设置的值，就会返回false。而且按照文档来说，write永远不会丢掉数据

			只会不断的往缓冲区里写数据，无论缓冲区是否超过设定的值，所以才会造成内存的问题。

		什么时候使用流:

			当内存中无法一次装下需要处理的数据时，或者一边读取一遍处理更加高效时，我们就要用到数据流

		优化（不适用pipe方法）:

			var http = require("http");
			var fs = require("fs");
			var filename = "file.iso";

			var serv = http.createServer(function (req, res) {
				var stat = fs.statSync(filename);
				res.writeHeader(200, {"Content-Length": stat.size});
				var fReadStream = fs.createReadStream(filename);
				fReadStream.on('data', function (chunk) {
					if(!res.write(chunk)){//判断写缓冲区是否写满(node的官方文档有对write方法返回值的说明)
						fReadStream.pause();//如果写缓冲区不可用，暂停读取数据
					}
				});
				fReadStream.on('end', function () {
					res.end();
				});
				res.on("drain", function () {//写缓冲区可用，会触发"drain"事件
					fReadStream.resume();//重新启动读取数据
				});
			});

			serv.listen(8888);

#. createReadStream

	实例方法:	open  data  end  error close pause resume

    设置编码有两种方式： 

        1. fs.createReadStream(path, [options]) options是一个对象

        2. rs.setEncoding("UTF8");        

    const rs = fs.createReadStream("./demo.txt", { encoding: "utf8" });
    let data = "";

    rs.on("open", fd => {
		console.log("文件已打开:", fd);
	});

	rs.on("data", chunk => {
		data += chunk;
		console.log("读取数据:", chunk);
	});

	rs.on("error", err => {
		console.log("读取失败", err);
	});

	rs.on("end", () => {
		console.log("数据读取结束", data);
	});

	rs.on("close", () => {
		console.log("文件已关闭");
	});

	Another：

		rs.pipe(process.stdout); 直接在终端（即cmd中打印出file信息）

		或

		rs.pipe(process.stdout);

		rs.on("end", () => {
			process.stdout.write("]");
		});

		process.stdout.write("文件读取成功，内容是[");

#. fs.createWriteStream	

	实例方法: finish  data  error  end  write drain

	readStream.on("data", chunk => {		
		if (!ws.write(chunk)) {		// 当待处理队列大于 highWaterMark 时返回false, 如果写入速度跟不上读取速度的话，只写数据流内部的缓存会爆仓
			rs.pause();				// 暂停数据读取
		}
	})

	ws.on("drain", () => {
		console.log("可写流处理完了积压数据会触发drain方法");
		readStream.resume();	// 恢复数据读取
	});

	2. 简单使用方法

		writeStream.write("啦啦啦啦啦啦");

		Or:

		readStream.pipe(writeStream);	// 将rs文件的内容写入到ws的目标文件中


#. process.stdout 和 process.stdin	

	1. 每进入一个逻辑（if-else）都会从头开始执行一遍代码，因为会不断监听 process.stdin.on("data")

	2. process.stdout.write 和 console.log 有什么不同.

		console.log = function (d) {
			process.stdout.write(d + '\n');
		};

		简而言之，就是console.log每次打印后面都会自动换行,而 process.stdout 则不会换行

	3. demo

		process.stdout.write("请输入用户名：");
		let username = "";

		let users = {
			"admin":"123",
			"user1":"321",
			"user2":"213"
		};

		process.stdin.on("data", input => {
			input = input.toString().trim();
			if (!username) {
				if (Object.keys(users).indexOf(input) === -1) {
					process.stdout.write("用户名不存在\n");
					process.stdout.write("请输入用户名：");
					username = "";
				} else {
					process.stdout.write("请输入密码:");
					username = input;
				}
			} else {
				if (input === users[username]) {
					console.log("登录成功");
				} else {
					process.stdout.write("请输入密码:");
				}
			}
		});

#. __dirname 和 __filename 和 process.cwd() 的不同

	__dirname, 返回所在js文件的目录, 绝对路径

	__filename, 返回所在js文件的完整路径, 绝对路径

	process.cwd(), 返回执行node命令时的目录

	例子:

		工程目录:

			nodejs
				u-Pan
					upload
						home.js
					about.js
					page.js

		终端执行:  E:\code\mine\nodejs\U-Pan 下执行 node upload/home.js

		home.js

			console.log(__dirname);    	// E:\code\mine\nodejs\U-Pan\upload
			console.log(__filename);  	// E:\code\mine\nodejs\U-Pan\upload\home.js
			console.log(process.cwd()); // E:\code\mine\nodejs\U-Pan （就是终端执行的path）

		about.js

			console.log(__dirname);    	// E:\code\mine\nodejs\U-Pan
			console.log(__filename);  	// E:\code\mine\nodejs\U-Pan\about.js
			console.log(process.cwd()); // E:\code\mine\nodejs\U-Pan

#. 压缩格式

	打包和压缩的是两个概念

		tar包, 就只是将多个文件打包成一个总文件，多个文件的文件大小并没有改变

		所以也经常配合其他的压缩工具一起使用,即 .tar.gz （tar是打包工具,把很多文件打包成一个文件, gz是压缩格式）

		rar，是打包及压缩

	.tar

	.rar

	.zip

	.gz		使用gzip压缩的文件

#. 压缩文件

	· 常见的 transform stream 包括 zlib, crypto(加密解密) 

	· 压缩跟解压不限于文件操作，也可以是数据压缩，http请求的压缩

	· 有两种常见的http压缩：deflate 和 gzip 

	1. 文件的gzip压缩

		const fs = require("fs");
		const zlib = require("zlib");	// zlib模块提供了用gzip和Deflate、Inflate实现的压缩功能
		const gzip = zlib.createGzip();

		const rs = fs.createReadStream("demo.txt");
		const ws = fs.createWriteStream("output.txt.gz");

		rs.pipe(gzip).pipe(ws);

		解压：

			var fs = require('fs');
			var zlib = require('zlib');

			var gunzip = zlib.createGunzip();

			var inFile = fs.createReadStream('./extra/fileForCompress.txt.gz');
			var outFile = fs.createWriteStream('./extra/fileForCompress1.txt');

			inFile.pipe(gunzip).pipe(outFile);


	2. 返回给客户端的是gzip
		
		const zlib = require('zlib');
		const http = require('http');
		const fs = require('fs');

		//client request example
		const request = http.get( { host: 'example.com', 
									path: '/',
									port: 80,
									headers: { 'Accept-Encoding': 'gzip,deflate' } } );
		request.on('response', (response) => {
			var output = fs.createWriteStream('example.html');
			var contentEncoding = response.headers['content-encoding'];
			console.log('response.headers[\'content-encoding\']: ' + contentEncoding);
			switch(contentEncoding) {
				case 'gzip':
					response.pipe(zlib.createGunzip()).pipe(output);
					break;
				case 'deflate':
					response.pipe(zlib.createInflate(zlib.createInflate())).pipe(output);
					break;
				default:
					response.pipe(output);
					break;
			}
		});

		//server example
		http.createServer((request, response) => {
			var rawStream = fs.createReadStream('example.html');
			var acceptEncoding = request.headers['accept-encoding'];
			console.log('response.headers[\'accept-encoding\']: ' + acceptEncoding);
			if(!acceptEncoding) {
				acceptEncoding = '';
			}
			if(acceptEncoding.match(/\bgzip\b/)) {
				response.writeHead(200, {'content-encoding': 'gzip'});
				rawStream.pipe(zlib.createGzip()).pipe(response);
			} else if(acceptEncoding.match(/\bdeflate\b/)) {
				response.writeHead(200, {'content-encoding': 'deflate'});
				rawStream.pipe(zlib.createDeflate).pipe(response);
			} else {
				response.writeHead(200, {});
				rawStream.pipe(response);
			}
		}).listen(8080);		

#. 在git.bash中查看环境变量

	process 表示当前node进程

	env
		该命令可以将当前操作系统中所有的环境变量都列出

	node文件中执行 console.log(process.env)	的得到的结果跟直接在终端输入 env 是一样的结果

	1. window中的环境变量（cmd终端）

		a. set	查询所有的环境变量

		b. set HELLO=hello	设置环境变量

			echo %HELLO%	查看环境变量

	2. linux中的环境变量

		#. 生命周期:

			永久的: 需要修改配置文件, 变量永久生效

			临时的:	使用export命令行声明即可,变量在关闭shell时失效

		#. 设置变量的三种方法:

			在etc/profile文件中增加变量，该变量将会对linux下所有用户有效，并且是"永久的"
				cd ~
				vi /etc/profile

			 在用户目录下的.bash_profile文件中增加变量【对单一用户生效（永久的）】

		a. set	查看所有的环境变量（所有本地定义的shell变量）

			env 只查看用户级别的环境变量

		b. 	export HELLO=hello 设置环境变量

			echo $HELLO 		查看环境变量

		c.	HELLO="HEIHEIHEI"	修改已存在的环境变量

			echo $HELLO

		d. 查看指定的环境变量是否生效（存在即生效）

			env | grep HELLO

			HELLO=HEIHEIHEI	（证明环境变量HELLO已存在）

		e. 删除环境变量

			unset HELLO

			env | grep HELLO

		f. 设置制度环境变量

			export MY=yangyang

			echo $MY

			readonly MY

			unset MY		// bash: unset: MY: cannot unset: readonly variable

			MY=cy 			// bash: MY: readonly variable

#. 获取当前文件的上级目录路径

	目录结构如下:

		E:
			code
				mine
					nodejs	
						review_stream.js
				notes
					nodeJS.txt

	review_stream.js

		去读取 nodeJS.txt 文件内容

		const path = require("path");

		const filePath = path.resolve(__dirname, "..", "..", "notes", "nodeJS.txt");	//  E:\code\notes\nodeJS.txt

#. NODE中命令行模式和nod交互模式的区分

	node交互模式就是:

		在终端输入node， 然后进入交互模式

	node index.js	就是命令行模式

#. 数据传递和背压反馈

	主要用于描述 可读流和可写流 之间的读取。

#.查看目录是否存在,不存在就新建该目录

	const logDirectory = path.join(__dirname, "log);

	fs.existsSync(logDirectory) || fs.mkdirSync(logDirectory);

	
#. url模块

	const url= require("url");

	方法:  

		1. url.parse(string, boolean, boolean)

			第二个参数:  返回的url对象中， query是一个对象(默认返回string)

			第三个参数:  slashDenoteHost, 主要用在相对协议url上, 如果为true, 表示//与之后的第一个/之间的字符串会被解析成host

				如: "//static.lagou.com/i/image/M00/01/80/CgqKkVZuPraAN3O6AACFeBgN7dY620.jpg"

				url.parse(url, true);	// URL对象中的host属性是null

				url.parse(url, true, true)	// URL对象中的host属性是 'static.lagou.com'

		2. url.format(urlObject);

			const urlObj = {
				"protocol": "http:",
				"slashes": true,
				"auth": "user:pass",
				"host": "host.com:8080",
				"port": "8080",
				"hostname": "host.com",
				"hash": "#hash",
				"search": "?query=string",
				"query": "query=string",
				"pathname": "/p/a/t/h",
				"path": "/p/a/t/h?query=string",
				"href": "http://user:pass@host.com:8080/p/a/t/h?query=string#hash"
			};

			url.format(urlObj);	// "http://user:pass@host.com:8080/p/a/t/h?query=string#hash";

		eg:  const url = "http://user:pass@host.com:8080/p/a/t/h?query=string#hash";

			a. url.parse(url);

				返回值是一个URL对象:
				{
					"protocol": "http:",
					"slashes": true,
					"auth": "user:pass",
					"host": "host.com:8080",
					"port": "8080",
					"hostname": "host.com",
					"hash": "#hash",
					"search": "?query=string",
					"query": "query=string",
					"pathname": "/p/a/t/h",
					"path": "/p/a/t/h?query=string",
					"href": "http://user:pass@host.com:8080/p/a/t/h?query=string#hash"
				}

			b. url.parse(url, true);

				{
					...
					query: {query: string},		// 当第二个参数为true时,返回的url对象中的query字段以对象的形式返回
					...
				}

				效果类似于；

					const qs = require("querystring");
					
					const { query } = url.parse(myUrl);	
					qs.parse(query);

#. 原生的nodejs中，如果获取 req.query

	http.createServer((req, res) => {
		const method = req.method;
		if (method.toLowercase() === "get") {
			console.log(req.query);		// 错误, 因为node中没有原生的req.query

			const { query } = url.parse(req.url, true);
			conosle.log(query);			// url.parse(urlString, boolean) 输出一个url对象, 其中包含query属性,默认是string（如 ?name=join），当第二个参数为true时,query属性输出格式为对象（{name: join}）

			const { name, age } = query;
			res.write(`I am ${name}, this year is ${age} old.`);
			res.end();		// write方法之后必须写end方法才能将数据发送到client端
		}
	}).listen(8082);

#. WHATWG URL

	const { URL } = require("url");
	const myUrl = new URL("http://user:pass@host.com:8080/p/a/t/h?query=string#hash");

	console.log("hash----------", myUrl.hash);
	console.log("host----------", myUrl.host);
	console.log("hostname----------", myUrl.hostname);
	console.log("href----------", myUrl.href);
	console.log("origin----------", myUrl.origin);
	console.log("username----------", myUrl.username);
	console.log("password----------", myUrl.password);
	console.log("port----------", myUrl.port);
	console.log("search----------", myUrl.search);		// ?query=string  其实就是query

#####   线程相关

    JS 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事

    单线程就意味着，所有任务需要排队，前一个任务结束，才回执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。

#. lint --exclude

	package.json

		scripts: {
			"lint": "ng lint --exclude=**/**.spec.ts",
		}

		lint的文件不报错 所有的 .spec.ts 文件

		** 匹配模式用的是 git 的模式，LINK：https://git-scm.com/docs/gitignore

		**用于整个项目中的递归调用,

		ab/**  匹配目录“ abc” 内的所有文件

		a/**/b 匹配“ a/b”，“ a/x/b”，“ a/x/y/b”等。斜杠后跟两个连续的星号，然后斜杠匹配零个或多个目录

#. 启用 hash 模式下的项目用node获取不到 # 之后的内容

	下面用egg做为演示, 获取channel的值

		http://localhost:4200/#/login?channel=12345

		1. 新建一个html文件用于获取 # 之后的内容 app/view/redirect.html

			<!DOCTYPE html>
			<html lang="en">

			<body>
				<form method="post" style="display: none">
					<input type="hidden" name="query">
				</form>
			</body>
			<script>
				let hash = window.location.hash;
				let query = hash.split('?');

				if (query.length > 1) {
					document.querySelector('input[name="query"]').value = query[1];
					location.hash = "";
				}

				document.querySelector('form').submit();
			</script>
			</html>

		2. router.ts

			router.get('/', controller.home.renderIndex);
			router.get('/sso/redirect', controller.ssoRedirect.ssoRedirect);
			router.post('/sso/redirect', controller.ssoRedirect.getQuery);			// 注意一个是post，一个是get
		
		3. controller/home.ts

			const haveRequestRedirect = this.ctx.cookies.get('haveRequestRedirect');
			
			if (!haveRequestRedirect) {
				await this.ctx.redirect('/sso/redirect');
			} else {
				await this.ctx.render('index.html', { gioKey, sentryKey, sentryEnv });
			}

		3. controller/sso-redirect.ts

			import { Controller } from 'egg';
			import { handler } from './base';

			export default class SsoRedirectController extends Controller {

				@handler()
				async ssoRedirect(): Promise<void> {
					await this.ctx.render('redirect');
				}

				@handler()
				async getQuery(): Promise<void> {
					const { query } = this.ctx.request.body;
					let channel: string;

					this.ctx.cookies.set('haveRequestRedirect', 'true');

					if (query) {
						channel = query.split('channel=')[1];
						this.ctx.cookies.set('testChannel', channel);
					}

					await this.ctx.redirect('/');
				}
			}
