知识汇总：

1. ajax
	
	上传进度和下载进度调用的是两个事件,progress事件

	onprogress事件处理程序会接收到一个event对象，其target属性是XHR对象，但包含着三个额外的属性：

		lengthComputable是一个表示进度信息是否可用的布尔值，

		position表示已经接收的字节数，

		totalSize表示根据Content-Length相应头部确定的预期字节数。

	有了这些信息，我们就可以为用户创建一个进度指示器了

	function progress(e) {
        if (e.lengthComputable) {
            progressVar = Math.round(e.loaded * 100 / e.total);
            console.log("progress: " + progressVar + "%");
            if (e.loaded = e.total) {
              console.log("File upload finished!");
            }
        }
    };

2. 关于文本文件的BOM

	UTF-8和 UTF-8（不带BOM）是两种格式文本，带BOM的utf-8多出了三个字节前缀，0xEF0xBB0xBF

	有了这三个字节前缀的文本或字符串，程序可以自动判断他为utf_8格式，并按照utf_8格式来解析文本或字符串,

	否则一个文本或字符串在位置编码的情况下，需要按照字符编码规范去一个个验证。

3. angularjs 输入框内按下回车会触发其他button的点击事件，

	解决办法： button 标签添加 type='button'

	Default type for the button element is 'submit' : 

		<button></button> ==== <button type='submit'></button>

	when you hit enter,the first button is submitted.


4. self指向当前数组

	angular.forEach(entity.modSecIds, function(element, index, self) {
		
		if(!element){
			self.splice(index,1);
		}
	});


5. $location.search('code',null)

	URL： http://192.168.111.171/ftz/#/MONGODB?code=KvZ4GQ

	$location.search('code',null) 可以将code 从当前url中删除
	
		  http://192.168.111.171/ftz/#/MONGODB


6. concat()

	用于连接两个或多个数组元素，返回值一个新数组

	arrayObj.concat(array1,array2,...); 参数可以是数组

	或

	arrayObj.concat(1,2,3,...);	也可以是具体的值


	eg:    var a = [1,2,3];

		   console.log( a.concat(4,5) ); // [1,2,3,4,5]


		   var b = ['apple','banana'];

		   console.log( a.concat(b) ); // [1,2,3,'apple','banana']



7. sort(fn)

	数组排序,参数必须是函数,返回值，排序后的数组

	a - b  --->  升序（小到大）

	b - a  --->  降序 

	arrayObj.sort(sortByFn)

	a)  arr.sort()  是按照字母顺序排序的

		var arr = [1,1000,10,25,40,5];

		console.log(arr.sort()); // [1, 10, 1000, 25, 40, 5]  可以看到并不是按照数值大小排序，而是字母顺序

	b) arr.sort(fn)   按照数值大小排序

		function sortNum(a,b){
			return a-b;
		};

		var arr = [1,1000,10,25,40,5];

		console.log(arr.sort(sortNum)); // [1,5,10,25,40,1000]


8. map(fn)

	数组方法, 将原数组映射成新数组，返回值是一个数组

	arrayObj.map(function(el){
		return el*2;
	});

	eg:		s var users = [
			  {name: "张含韵", "email": "zhang@email.com"},
			  {name: "江一燕",  "email": "jiang@email.com"},
			  {name: "李小璐",  "email": "li@email.com"}
			];

			var email = users.map(function(user){
				return user.email;
			});
			
			console.log(email); // ["zhang@email.com", "jiang@email.com", "li@email.com"]

			console.log(users)  //  还是原来的users


9. Object.defineProperty() 

	方法会直接在一个对象上定义一个新属性或者修改已有的属性，并返回这个对象。

	set / get

	writeable --- true / false

	enumable  --- 用于是否可以 for...in 或 Object.keys()

		1.	var arr5 = [1,2,3,4,5];

			arr5.length = 0;

			console.log(arr5); // []，所有的元素都被删除了


		2.	var arr5 = [1,2,3,4,5];

			Object.defineProperty(arr5,'length',{
				writable:false
			});

			arr5.length = 0;
		
			console.log(arr5); // [1,2,3,4,5]，不能修改length属性

		3. 利用该API实现双向数据绑定

			var a = {};

			Object.defineProperty(a,'b',{

				newValue:'',

				set:function(newValue){
					this.newValue =  newValue;
				},
				get:function(){
					return this.newValue;
				}

			});

			a.b = 'join';
			console.log(a.b); // join

			a.b = 'apple'; // apple

		4. HTML:

				<div id='test'>测试<>

			JS:

				var view = document.getElementById('test');

				var i = 0;

				var data = {};

				Object.defineProperty(a,'view',{

					set:function(newValue){
						view.textContent = newValue;
					},
					get:function(){
						
					}

				});

				setInterval(function(){
					i++;
					data['view'] = '更新界面'+i;
				},1000);


10. isNaN() 用于检查是否是数值,是数值返回false, 不是数值返回true
	
	// 返回false，会进行隐形转换
	console.log( isNaN(0) );
	console.log( isNaN(2) );
	console.log( isNaN('3') );		// 转换成3
	console.log( isNaN(true) );		// 转换成1
	console.log( isNaN(false) );	// 转换成0
	console.log( isNaN('') ); 		// 转换成0

	// 返回true
	console.log( isNaN(NaN) );
	console.log( isNaN('apple') );


11. 编程技巧

	I. 当一个函数包含超过三个形参时，要记住调用函数中实参的正确顺序并不容易。

		解决办法：将形参定义为一个对象，需要的字段都作为该对象的属性，这样就不用记顺序了

		eg:      function test($scope, entity, action, isBig){
					 ....
				 }


				 var paramsValue = {
				 	scope:$scope,
				 	entity:entity,
				 	action:action,
				 	isBig:isBig
				 };

				 function test(paramsValue){
				 	...
				 };

				 test(paramsValue);


	II. 要回抛错

		throw new Error('这是一个自定义错误！');

	III. 	(function(){
				...
			}());

			当与别人协同开发时，为了避免变量冲突和污染，最好将代码卸载以上格式的函数中，
			我们可以称之为 模块，可以避免全局变量污染。

			注意， function左边的括号，不可以省略，因为如果不写这个左圆括号，js解释器会视图将关键字function解析为函数声明语句，而包裹在括号中，解释器才会正确的将其解析为函数表达式。使用圆括号是习惯用法，尽管有时候没有必要，但也不应当省略。


12. WebSocket

	HTTP协议是一种无状态协议，服务器本身不具有识别客户端的能力，必须借助外部机制，比如session和cookie，才能与特定客户端保持对话，这多少带来一些不便，尤其在服务器端与客户端需要持续交换数据的场合（比如网络聊天），为了解决这个问题，HTML5提出了浏览器的WebSocket API。

	WebSocket的主要作用是：允许服务器端与客户端进行全双工(full-duplex)的通信，举例来说，HTTP协议有点像发电子邮件，发出后必须等待对象回信，而WebSocket则像是打电话，服务器和客户端可以同时向对方发送数据，他们之间存在着一条持续打开的数据通道。


	WebSocket协议完全可以取代Ajax方法，用来向服务器端发送文本和二进制数据，而且还没有“同域限制”。

	WebSocket不是用HTTP协议，而是使用自己的协议，

		A） 浏览器发出的WS请求头信息类似于下面的样子：

			GET / HTTP/1.1
			Connection:Upgrade
			Upgrade:websoket
			Host:example.com
			Origin:null
			Sec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==
			Sec-WebSocket-Version:13


		解读：  有一个HTTP头是Upgrade. HTTP1.1协议规定，Upgrade头信息表示将通信协议从HTTP/1.1 转向该项所指定的协议。

				Connection:Upgrade，就表示浏览器通知服务器，如果可以，就升级到ws协议

				Origin用于验证浏览区域名是否在服务器许可的范围内。

				Sec-WebSocket-Key，则是用于握手协议的密钥，是base64编码的16字节随机字符串


		B） 服务器端的ws响应头：

			HTTP/1.1 101 Switching Protocols
			Connectino:Upgrade
			Upgrade:websocket
			Sec-Websocket-Accept:fFBooB7FAkLlXgRSz0BT3v4hq5s=
			Sec-WebSocket-Origin: null
			Sec-WebSocket-Location: ws://example.com/

		解读：	服务器端同样用 Connectino:Upgrade 通知浏览器需要改变协议。

				Sec-Websocket-Accept，是服务器在浏览器提供的 Sec-WebSocket-Key 字符串后面，添加 'fFBooB7FAkLlXgRSz0BT3v4hq5s=' 字符串，然后再取 sha-1 的hash值。 浏览器将对这个值进行验证，以证明确实是目标服务器回应了ws请求。

				Sec-WebSocket-Location表示进行通信的WS网址




	· 完成握手后，ws协议就在TCP协议之上，开始传送数据

	· WS协议需要服务器支持，目前比较流行的实现是给予node.js 的socket.io。
		至于浏览器端，目前主流浏览器都支持ws协议（IE10+）,


	` 代码实现

		// 1.客户端检查浏览器是否支持WS
		if( window.WebSocket !== undefined ){

			// WS代码  2. 与服务器建立连接
			var ws = new WebSocket('ws://localhostL8081');

			// 3. ws 是 WebSocket的实例对象，该对象有一个 readySate属性，表示目前的状态，有四个值 

				0：正在连接
				1: 连接成功
				2：正在关闭
				3：连接关闭


			// ws一共支持四个消息：onopen onmessag onclose onerror
	        // 当browser和ws连接成功后，会触发onopen消息
	        ws.onopen = function(evt) { 
	            websocket.send(evt); 
	        }; 

	        // 当browser接收到ws发送来的数据时，就会触发onmessage消息，event中包含server传输过来的数据
	        ws.onmessage = function(evt) { 
	            onMessage(evt) 
	        }; 

	        // 当browser接收到ws发送的关闭连接请求时，就会触发onclose消息
	        ws.onclose = function(evt) { 
	            onClose(evt) 
	        }; 

	        // 如果连接失败，发送，接受数据失败或者和处理数据出现错误，browser会触发onerror消息
	        ws.onerror = function(evt) { 
	            onError(evt) 
	        }; 

		 
		    function onClose(evt) { 
		        writeToScreen("断开"); 
		    }  
		 
		    function onMessage(evt) { 
		        writeToScreen('<span style="color: blue;">RESPONSE: '+ evt.data+'</span>'); 
		        websocket.close(); 
		    }  
		 
		    function onError(evt) { 
		        writeToScreen('<span style="color: red;">ERROR:</span> '+ evt.data); 
		    }  
		 
		    function writeToScreen(message) { 
		        var pre = document.createElement("p"); 
		        pre.style.wordWrap = "break-word"; 
		        pre.innerHTML = message; 
		        output.appendChild(pre); 
		    }  


		}


	Socket.io是目前最流行的WebSocket实现，包括服务器和客户端两个部分。它不仅简化了接口，使得操作更容易，而且对于那些不支持WebSocket的浏览器，会自动降为Ajax连接，最大限度地保证了兼容性。它的目标是统一通信机制，使得所有浏览器和移动设备都可以进行实时通信。

	其本质是先通过HTTP/HTTPS协议进行握手后创建一个用于交换数据的TCP连接，服务端与客户端通过此TCP连接进行实时通信。


	c) 浏览器查看 ws 的传输过程

		netWort -> filter(是个icon) -> WS -> 只显示ws协议的请求 -> 点击单个请求的 Frames 可以看到发送给服务器以及服务器返回的数据(发送给服务器的数据的背景色是绿色)

	d) 请求头  和 响应头

		HTTP/1.1 101 Web Socket Protocol Handshake
		Access-Control-Allow-Credentials: true
		Access-Control-Allow-Headers: content-type
		Access-Control-Allow-Headers: authorization
		Access-Control-Allow-Headers: x-websocket-extensions
		Access-Control-Allow-Headers: x-websocket-version
		Access-Control-Allow-Headers: x-websocket-protocol
		Access-Control-Allow-Origin: null
		Date: Tue, 19 Sep 2017 09:30:12 GMT
		Sec-WebSocket-Accept: O3ZaRYPPdjoMFNU/FVXmWi2lEO0=
		Server: Kaazing Gateway			--- 是一种提供跨平台跨浏览器WebSocket支持的网关，由Java编写
		Connection: Upgrade 			--- 下面两条表示，使用的是 ws协议，而非http协议
		Upgrade: websocket



		GET ws://echo.websocket.org/ HTTP/1.1
		Host: echo.websocket.org
		Connection: Upgrade
		Pragma: no-cache
		Upgrade: websocket
		Origin: file://
		Sec-WebSocket-Version: 13 
		Sec-WebSocket-Key: mSPm9O/nmD4KfW4b5fbpfA==     --- 对应请求头中的 Sec-WebSocket-Accpet 	
															返回客户端，就表示ws连接成功
		Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits



	e) WebSocket 协议采用的是 101状态码，server可能返回 两种101 reason-phrase (原因短句)

		1）HTTP/1.1 101 Switching Protocol

		2）HTTP/1.1 101 Web Socket Protocol Handshake

	f) 与HTTP协议的请求/响应模式不同，ws在建立连接之前有一个 handshake (opening handshake) 过程，在关闭连接之前也有一个handshake过程（close handshake）过程，建立连接之后，双方即可双向通信。

	在ws协议发展过程中前前后后就出现了多个版本的握手协议：

		1）基于 flash 的握手协议

			使用场景是IE的多数版本，因为IE的多数版本不都不支持ws协议，以及ff,chrome等浏览器的低版本，还没有原声的支持ws，此处，server唯一要做的是，就是准备一个 WebSocket-Location域给client，没有加密，可靠性很差。

			request header:

				GET / ls HTTP/1.1
				Upgrade: WebSocket
				Connection: Upgrade
				Host: www.example.com
				Origin: http://www.example.com

			response header:

				HTTP/1.1 101 Web Socket Protocol Handshake
				Upgrade: WebSocket
				Connection: Upgrade
				WebSocket-Origin: http://www.example.com
				WebSocket-Location: http://www.example.com/ls



		2）基于 md5 的握手协议

			request header:

				GET /demo HTTP/1.1
				Host: example.com
				Connection: Upgrade
				Sec-WebSocket-Key2: 
				Upgrade: WebSocket
				Sec-WebSocket-Key1: 
				Origin: http://www.qixing318.com
				[8-byte security key]

			response header:

				HTTP/1.1 101 WebSocket Protocol Handshake
				Upgrade: WebSocket
				Connection: Upgrade
				WebSocket-Origin: http://www.qixing318.com
				WebSocket-Location: ws://example.com/demo
				[16-byte hash response]

		3）基于 sha 的握手协议
		
			也是目前见的最多的一种方式，这里的版本号目前是需要13以上的版本

			request header:

				GET /ls HTTP/1.1
				Upgrade: websocket
				Connection: Upgrade
				Host: www.qixing318.com
				Sec-WebSocket-Origin: http://www.qixing318.com
				Sec-WebSocket-Key: 2SCVXUeP9cTjV+0mWB8J6A==
				Sec-WebSocket-Version: 13

			response header:

				HTTP/1.1 101 Switching Protocols    ---所有非101的状态码都表示handshake并未完成。
				Upgrade: websocket
				Connection: Upgrade
				Sec-WebSocket-Accept: mLDKNeBNWz6T9SxU+o0Fy/HgeSw=




13. DOM事件
	
	oninput   onpropertychange   onchange

	a) onchange触发需满足两个条件

		当前对象属性改变，并且由键盘或鼠标事件触发的（脚本触发无效）

		当前对象失去焦点(onblur)触发

	b) onpropertychange 只要当前对象属性发生改变，都会触发事件，IE专属

	c) oninput 是 onpropertychange 的非IE浏览器版本，支持ff, opera等浏览器，但有一点不同，他绑定对象时，并非该对象属性改变都能出触发事件，value值发生改变是有效


14. ng-repeat 对象时，并不是按照顺序来的，其实就是因为Object类型for in时没有固定顺序的，是无序的

	Object类型for in时没有固定顺序的

	优先使用数组而不是Object类型来表示有顺序的集合，(确实，对象的数据结构定义就是无序集合)

	为什么：

			ECMA 标准并没有规定对js的Object类型中的属性的存储顺序，但是在使用for..in循环中对Object中的属性进行遍历的时候，确实是需要依赖于某种顺序的。正式因为ECMA没有对这个顺序进行明确的规范，所以每个js执行引擎都能够根据自身的特点进行实现。那么在不同的执行环境中就不鞥保证for..in循环的行为一致性了。



	如果你确实需要保证运行的结果是建立在数据的顺序上，优先使用数组类型来表示数据，而不是直接使用Object类型。同时，也尽量避免使用for..in循环，而使用显式的for循环：

	 
	总结：
		在使用for..in循环时，不要依赖于遍历的顺序。
		当使用Object类型来保存数据时，需要保证其中的数据是无序的。
		当需要表示带有顺序的集合时，使用数组类型而不是Object类型。


15. 101状态码

		服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 　　只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。

	WebSocket 协议采用的是 101状态码

16. echarts

	每个折点都显示数值:  在 series中添加 itemStyle : { normal: {label : {show: true}}},

17. shebang 符号（#!）
	
	该符号在unix类的操作系统才有意义

	#!/user/bin/env python 和 #!/user/bin/python 的区别


	#!/user/bin/python 是告诉操作系统执行这个脚本的时候,调用/user/bin下的Python解释器

	#!/user/bin/env python 这种用法是为了防止用户没有讲Python装在默认的/user/bin路径下。当系统看到这一行的时候，首先会到env设置里查找python的安装路径，再调用对应路径下的解释器程序完成操作。（推荐这种写法）


18. setDate(1~31)

	可以获取该月某一天的时间格式：

	var curDate = new Date();

	curDate.setDate(12);  // 该方法的参数是必须的，12说明获取该月12号的date格式

	console.log(curDate); // Sun Nov 12 2017 16:24:14 GMT+0800 (中国标准时间)


19. getDate()

	返回某月的某一天，1~31


20. 获取明天的当前时间

	var today = new Date();

  	nextWeek.setDate(nextWeek.getDate() + 7);  // 获取一周之后的时间

21. js 生成dom节点

	var html = '';

	html += '<ul class="list">';

	for(var i=1; i<9; i++){
		html += '<li><img src="imgs/' +i+ '.jpg"></li>';
	}

	html += '</ul>';

	$('.box').html(html);  // html() 方法可以渲染标签,如果这里使用append(),则是原样显示到界面上，一堆字符串,并不会渲染


22. $.extend 和 angular.extend()

	功能是一样的,以$.extend说明用法

	var obj1 = {name:'apple', age:34};

	var obj2 = {age:45};

	var obj3 = $.extend({}, obj1, obj2);  //  obj2覆盖obj1的相同属性  {name:'apple',age:45}


23. 自己封装JQ插件

	jq提供了两种方法可以在jq上添加方法

	$.fn.extend()  -> $('#img').preload();  // 需要先选择一个元素

	$.extend()	   -> $.preload();			// 不需要元素

	eg:   $.extend({
				preload:function(imgs, opts){
					new PreLoad(imgs, opts);
				}
		  })

		  $.preload(imgs,{
		  	each:function(){
		  		....
		  	}
		  })


24. 点击空白处去销售事件冒泡

	$('button').on('click',function(event){

		event.stopPropagation();  // 取消事件冒泡

		$('h1').show();
	});

	// 点击空白处关闭h1，需要取消事件冒泡，否则h1一直显示不出来
	$(document).on('click',function(){
		$('h1').hide();
	});


25. 事件的绑定和清除

		// 键盘事件
		document.onkeydown = function(e){
			if(e.keyCode == 38){ // rotate
				game.rotate();
			}else if(e.keyCode == 39){ // right
				game.right();
			}else if(e.keyCode == 40){ // down
				game.down();
			}else if(e.keyCode == 37){ // left
				game.left();
			}else if(e.keyCode == 32){ // space
				game.fall();
			}
		};

		// 清除键盘事件
		document.onkeydown = null; (一般来讲，直接置为Null,可以初始化所有的something)


		if(timer){ 		// 关掉定时器
			clearInterval(timer);
			timer = null;	（可以看到timer重置为null）
		}


26. js中的堆内存（heap）和栈内存（stack）

	JS运行的时候会有堆内存（heap）和栈内存（stack），当我们new实例化一个类的时候，这个new出来的对象就保存在heap里面，而这个对象的引用则存储在stack中。程序通过stack里的引用找到这个对象。

	var arr = [1,2,3];

	其中arr是[1,2,3]的引用，保存在stack中，heap里存储的内容是[1,2,3]

27. 内存泄漏（memory leak）和内存溢出（out of memory）

	内存溢出，是指程序在申请内存时，没有足够的内存空间供其使用，比如说栈，栈满时在做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢，就是分配的内存不足以放下数据项序列，称为内存溢出。

	内存泄漏是指，你想系统申请分配内存进行使用，可是使用完以后却不归还（dlete）,结果你申请到的那块内存你自己也不能在访问（也许你把它的地址弄丢了），而系统不能再次将他分配他需要的程序。

	一次性内存泄漏并没有什么危害，因为他不会堆积，真正有危害的是内存泄漏的堆积，这会最终耗尽系统所有的内存。

	先保障交互逻辑，在调整细节。


28. localStorage 和 sessionStorage 在IE中也是支持的，但是必须是服务器上的文件，就是通过服务器打开，不支持本地文件

29. ngResource
		
	.constant('BASEURL', "http://192.168.64.219:8081/")

	第一种写法：

		var User = $resource('/user/:userId', {userId:'@id'});
		var user = User.get({userId:123}, function(){
			user.abc = true;
			user.$save();
		});

	第二种写法：

		var url = dataUrl + 'interface';
        var url1 = dataUrl + 'interface/:id';
        var url2 = dataUrl + 'interface/module';
        return $resource(url, {}, {
            'getAll': { method: 'JSONP', url: url+'?callback=JSON_CALLBACK',params:{}},
            'getOne': { method: 'JSONP', url: url1+'?callback=JSON_CALLBACK'},
            'update': { method: 'PUT', url: url1 },
            'delete': { method: 'DELETE', url: url1 },
            'getApi': { method: 'JSONP', url: url2+'?callback=JSON_CALLBACK',params:{}}
        });

    总结：

		HTTP GET “类”动作: Resource.action([parameters], [success], [error])
		non-GET “类”动作: Resource.action([parameters], postData, [success], [error])
		non-GET 实例动作: instance.$action([parameters], [success], [error])

		Success回调以(value, responseHeaders)参数调用。Error回调以(httpResponse)参数回调。


	问题:

		1. $resource(url, params?, 自定义方法{})

			第二个参数是什么？

			.factory('UserCardResource', ['$resource', function ($resource) {

				var url = '/user/:userId/card/:cardId';   { userId: 12, cardId: '@id' }

				var url2 = '/card/user/:userID/:id';      {userID:123,id:'@id'}

			    return $resource(
			    	url,
			    	{ userId: 12, cardId: '@id' },
			        { charge: { method: 'post', params: { charge: true }, isArray: false } });
			}]);

			参数解说：
				参数1：url 必须，url中带有:项的是根据参数2来进行配置的,如果设置的没有出现在url模板中，将会以search query的方式添加，
					eg: 
						url：/card/user/:userID/:id  ---  {userID:123, name:'john', id:'@id'}
						最终的url会变成： /card/user/123？name='john'

					如果参数值是以@开头的，那么其真实值将会从数据对象中提取？？？
					
				参数2：可空，配置url中带有：项的参数params，即url里面的参数
				参数3：可空，为自定义资源方法

			cardId: '@id' ??? @id是什么意思?

			将resource封装成服务后，调用：

			cardResource.action([parameters], [success], [error])

			第一个参数是params，如果没有可以不填，可以直接写successCallback，	

			[success], function(data header){....}

30. js的根对象是：Object.prototype对象,它是一个空的对象，在js中遇到的每个对象实际上都是从这个对象clone而来，就是他们的原型，

31. 原型链并不是无限长的，我们尝试访问对象a的address属性（实际上a并没有这个属性），而对象b和它构造器的原型上都没有address属性，name这个请求会被最终传递到哪里？

	实际上当请求达到A.prototype，并且在A.prototype中也没有找到address属性的时候，请求会被传递到A.prototype的构造器原型Object.prototype,显然Object.prototype中也没有该属性，但是Object.prototype的原型是null，说明这时候原型链的后面已经没有别的节点了，所以该次请求就到此打住，a.address返回undefined。


32. call 和 apply
	
	x.showName.call(y,m,n);

	用x代替y,也就是x的方法放在y上执行。m,n是参数

	eg:
		function add(m,n){
			return m + n;
		};

		function sub(m,n){
			return m - n;
		};

		console.log( add(5,3) ); 				// 8
		console.log( add.call(sub,5,3) );		// 8，用add替换sub
		console.log( add.apply(sub,[5,3]) );	// 8

		console.log( sub.apply(add,[5,3]) );	// 2
		console.log( sub.call(add,5,3) );		// 2

		

33. 应用测试

	应用测试有很多类型，最为常见的是单元测试和端对端测试（也称为集成测试）、

	单元测试是测试代码自身行为的一种测试。

	集成测试是模仿用户行为的一种测试。比如登录系统，创建帖子，退出系统等这些操作都可以自动化，并且可以用眼睛看到其过程是怎么发生的。

	angular2	e2e模块就是端对端测试模块


34. RPC架构

	Remote Promote Call, 一种进程间通信方式，允许像调用本地服务一样调用远程服务。

	PRC框架的主要目标就是让远程服务调用更简单、透明。RPC框架负责屏蔽底层的传输方式（TCP或者UDP）.

	序列化方式（XML/JSON/二进制）和通信细节。开发人员在使用的时候只需要了解谁在什么位置提供了什么

	服务接口即可，并不需要关心底层通信细节和调用过程。

35. 图片算法

	通常在网页中看到的图片有两种加载方式：一种从模糊然后逐渐清晰，另一种逐行加载显示清晰的图片。
	造成这种方式的原因是如偏的压缩算法不同，第一种是小波算法，第二种是离散余弦变换。

	从用户体验上来京第一种加载方式无疑更加友好，制作方式，就是用PS导出时做些配置：

	PNG图片使用PS导出时，勾选交错；
	JPG图片使用PS导出时，勾选连续；

	导出的图片就是从模糊到清晰的效果了，通常称为交错式PNG和渐进式JPG。（有人说没有这个选项？）

	另外一种方式：

		<img src="缩略图.jpg" name="pic" width="800" height="600" id="news" />

		然后用js处理：

		var img = new Image();//新建一个图片对象 
		img.src = "原图.jpg"; //最终显示的大图
		img.onload = function() { 
			document.getElementById('news').src = this.src; 
		}

36. 相对协议

	如果你的网站同时准备了https资源和http资源，name可以使用相对协议帮你实现当网站引入的都是http资源，网站域名更换为https后的无缝切换。

	如： <img src='//domain.com/img/logon.png'>

	简而言之，就是讲URL的协议（http,https）去掉，只保留//及后面的内容

	注意：如果是浏览本地文件，浏览器通过file://协议发送请求,导致请求失败，因此本地测试最好是搭建一个本地服务器

37. placeholder="{{fn.sample}}" 

38. CSS技术方案

	css全局作用域问题：css的规则都是全局的,协作开发时可能会冲突，我们的追求是sandBoxed（沙箱化）

	说到底就是css作用域的问题，

	技术方案： sass / less / postCss / css Modules / styled-component / stylus / BEM约定 等

	BEM： block element modifier 块 元素 修饰符

	而vue中则是提供了scoped是关键词来解决作用域问题

		<template>
		  <button class="button button-close">X</button>
		</template>

		<!-- 使用 `scoped` 特性 -->
		<style scoped>
		.button {
		  border: none;
		  border-radius: 2px;
		}

		.button-close {
		  background-color: red;
		}
		</style>

39. ES5方法

	1. Date.now() 获取当前时间戳

		console.log(Date.now());			// ES5 1524903182416			
		console.log(new Date().getTime());	// ES3 1524903182416

	2. JSON.parse()	 json的序列化和反序列化

		eval('({"a": 3})')		// ES3
		JSON.parse('{"a":3}') 	// ES5

	3. String.trim()

		var str = ' 123  456  ';
		var trim = str.trim();
		console.log('|'+trim+'|');
		console.log('|'+str+'|');

	4. 继承

		ES5:

			var Rectangle = function (id, x, y, width, height) {
			    Shape.call(this, id, x, y);
			    this.width  = width;
			    this.height = height;
			};
			Rectangle.prototype = Object.create(Shape.prototype);
			Rectangle.prototype.constructor = Rectangle;

		ES3:

			var Rectangle = function (id, x, y, width, height) {
			    Shape.call(this, id, x, y);
			    this.width  = width;
			    this.height = height;
			};
			Rectangle.prototype = new Shape();

		总结：ES5使用了Object.create()可以实现正确的继承，而ES3缺乏Object.create则只能写出不完美的继承（子类还未实例化父类已经实例化执行了构造函数，构造函数不带参数可能报错）

40. 原型链
	
	每个JS版本的实现方法略有不同，应比较阐述

	https://blog.csdn.net/iispring/article/details/62219444