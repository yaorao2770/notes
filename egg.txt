1. app/public 下面把 client dist下的代码cpoy过来

2. 浏览器访问前缀  localhost:7001/public/index.html

3. 加prefix : / 在 config.default.ts中, 浏览器访问 localhost:7001/index.html

4. 如果想 localhost:7001 直接就跳转到 index.html，需要添加

    config.errorFailOver = {
        ignorePath: [/^\/api/, /^\/[a-zA-Z]+-api/],
        failoverPath: path.resolve(appInfo.baseDir, "app", "public", "index.html"),
    };

    注意： config/plugin.ts 中也要写上下面，告诉去哪里找 error-fail-over

        const plugin: EggPlugin = {
            errorFailOver: {
                enable: true,
                package: "@gr-egg/error-fail-over",
            }
        };  

    并且  controller/router.ts 中默认路由要去掉

5. 不管当前是什么环境，都会执行 config.default.ts    

    所以 其他环境的config文件，如 config.local.ts 等也会执行，相当于

    同时会执行 config.default.ts  和 config.local.ts ，那么local文件中的同名属性 config.xxx会覆盖default文件中的

6. server 下的 proxy-config.json  其实用到的是  api_proxy 这个库（gr-egg） 

    "/demeter-api": {
        "target": "DEMETER_ENDPOINT",
        "logLevel": "debug",
        "pathRewrite": {
            "^/demeter-api": "/api/v1"
        }
    },

    最后实际的api地址是：  DEMETER_ENDPOINT + pathRewrite （DEMETER_ENDPOINT/api/v1）

#.  
    1. 直接相当于 ctx.body

        await this.ctx.render('news/list.html', {lists: newList}); 

    2. 需要手动赋值

        this.ctx.body = await this.ctx.renderString(`{{helper.lowercaseFirst("JOPIN")}}`, datas);

        this.ctx.body = await this.ctx.renderView('news/list.html', datas);


#. ctx.status = 403;
    ctx.message = 'GO away, robot';

    在client端看见的就是 httpcode 后面展示的文字，就是message的内容

#. 使用html后缀模板文件

    exports.view = {
        defaultViewEngine: 'nunjucks',
        // defaultExtension: '.html'            // 这里两种方式都可以
        mapping: {
            '.html': 'nunjucks'
        }
    };

#. middleware 中获取config.default的配置

    // config.default.js

        exports.authGuard = {
            enable: true
        };

    // auth-guard.js

        module.exports = (options, app) => {
            return async function authGuardMiddleware(ctx, next) {
                const match = options.enable;
                console.log('match----------', match);
                await next();
            };
        };

    总结： options 就等于 中间件的文件名，驼峰，即 options === app.config.authGuard

#. index 页面的js加载不到是因为 路径不对，在本地的时候，build的文件都在dist目录下，js文件跟index是同级目录，所以 config.local.ts    

    中应该设置 

    const staticDir = path.join(appInfo.baseDir!, '..', 'dist');
    
    config.static = {
        dir: staticDir,
        gzip: true,
        buffer: false,
    };

#. Context

    Context指的是Koa的请求上下文，这是请求级别的对象，每次请求生成一个Context实例，通常也简写成 ctx。

    Context上也挂在了Request 和 Response 两个对象。 

        只读： this.ctx.query

        只读： this.ctx.hostname

        可写： this.ctx.body

        可写： this.ctx.status



    在所有的文档中，Context和ctx都是指Koa的上下文对象

    ` middleware中 this 就是ctx，eg: this.cookies.get('foo');

    ` controller中有两种写法：

        类的写法通过 this.ctx

        方法的写法直接通过 ctx入参

    ` helper/service中的this指向它们本身，使用 this.ctx访问context对象， eg: this.ctx.cookies.get('foo');

    ` 框架会把 app/extend/context.ts 中定义的对象与Koa Context的 prototype 对象进行合并，

        在处理请求时会急于扩展后的 prototype 生成ctx对象

        this.logger.info('[restful] %s %s', requestOptions.method, api);

        this.app.logger.debug(`开始请求中间层`, url, opts);

        为什么有的是 this.app.logger 有的是 this.logger 呢？？？？？？

    ` controller / middleware / helper / service中都可以通过 this.app 访问到 Application 对象。

        例如 this.app.config 访问配置对象。 在 app.js 中app对象回座位第一个参数注入到入口函数中

    ` Request 对象 和 Response 对象

        ctx.request

            ctx上很多属性和方法都被代理到 request 对象上，对于这些属性和方法使用 ctx 和 使用 request去访问让他们是等价的。如

            ctx.url === ctx.request.url

        ctx.response

            ctx上很多属性和方法都被代理到 request 对象上，对于这些属性和方法使用 ctx 和 使用 request去访问让他们是等价的。如

            (ctx.status = 404) === (ctx.response.status = 404)

#. /config 目录

    config
        config.default.ts
        config.local.ts
        config.prod.ts

    在config.xx.ts中的定义的属性，可以在外面直接通过 this.config.xxx来访问，如下：

        config.default.js:

            exports.robot = {
                ua: [
                    /curl/i,
                    /Baiduspider/i,
                ]
            };

        app/service/some.js

            const Service = require('egg').Service;

            class SomeService extends Service {
                async list() {
                    const rule = this.config.robot.ua;
                }
            }

#. Application对象

    ` 在 controller 文件中以 this.app的形式获取（在继承与 Controller, Service 基类的实例中，可以通过 this.app 访问到 Application对象 ）

        app/controller/user.js

            class UserController extends Controller {
                async fetch() {
                    this.ctx.body = this.app.cache.get(this.ctx.query.id);
                }
            }

    ` 在 Context 对象上，可以通过 ctx.app 访问到 Application 对象

        app/controller/user.js

            class UserController extends Controller {
                async fetch() {
                    this.ctx.body = this.ctx.app.cache.get(this.ctx.query.id);
                }
            }

#. Controller

    该基类有下列属性,可以通过 this.xxx 使用

        ctx - 当前请求的 Context 实例。
        app - 应用的 Application 实例。
        config - 应用的配置。
        service - 应用所有的 service。
        logger - 为当前 controller 封装的 logger 对象。   

#. logger

    内置的

    logger.debug()
    logger.info()
    logger.warn()
    logger.error()             

#. controller和serveice分别是做什么的

    编码流程： 写路由文件，写对应的controller层，写对应的service层

    controller层： 验证参数，调用服务层，返回client数据

    service层： 访问持久化层，获取数据，返回格式化数据

    重复性代码要么配置化，要么封装为函数调用，尽量让每个文件不要杂糅太多信息。

    尽量使用 TypeScript 或者 ESLint 规范团队代码风格，使用 git + pre-commit 效果很不错哦。
    
    egg 项目开发请多参考 egg-example 开源项目，真的并不难哦。

#. const { customerId } = this.ctx.params;

    有两种写法：

        router.get("/api/customer/:customerId/detail", customerCtrl.detail);    

        router.get(API_PATH.FundCallbackStatus(':customerId'), customerCtrl.detail);

        export const API_PATH = {
            FundCallbackStatus: customerId => `/api/customer/${customerId}/detail`,
        };